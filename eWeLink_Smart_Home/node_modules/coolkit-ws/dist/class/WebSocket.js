"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const getWsIpServices_1 = __importDefault(require("../services/getWsIpServices"));
const tools_1 = require("../utils/tools");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const eventEmitter_1 = __importDefault(require("./../utils/eventEmitter"));
const enum_1 = require("../ts/enum");
class WebSocketService {
    constructor(config) {
        this.wsState = 'CONNECTED';
        WebSocketService.connectConfig = config;
    }
    _initWs() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const { region, useTestEnv = false } = WebSocketService.connectConfig;
                WebSocketService.listenerHook = tools_1.getListenerHook(WebSocketService.connectConfig);
                const disps = getWsIpServices_1.default(region, useTestEnv);
                const ws = new isomorphic_ws_1.default(`wss://${disps}:8080/api/ws`);
                eventEmitter_1.default.once(WebSocketService.listenerHook, (ev) => {
                    ev.error === 0 && console.log('WS:连接成功');
                    resolve(ev);
                });
                WebSocketService.isReconnecting && eventEmitter_1.default.once(`${enum_1.EEventType.RECONNECT_STATUS}`, (ev) => resolve(ev));
                ws.onclose = (ev) => this.onClose(ev);
                ws.onopen = (ev) => this.onOpen(ev);
                ws.onerror = (ev) => this.onError(ev);
                ws.onmessage = (ev) => this.onMessage(ev);
                WebSocketService.ws = ws;
            }));
        });
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            WebSocketService.isOpen = false;
            WebSocketService.isReconnecting = true;
            WebSocketService.ws = null;
            WebSocketService.hbInterval && clearInterval(WebSocketService.hbInterval);
            for (let count = 0; count < 10; count++) {
                if (!WebSocketService.isOpen) {
                    console.log(`长连接重连第 ${count + 1} 次`);
                    const res = yield this._initWs();
                    if (res.error !== 0) {
                        console.log(`长连接重连第 ${count + 1} 次失败`, res.msg);
                        continue;
                    }
                }
                break;
            }
            if (!WebSocketService.isOpen) {
                const errorMsg = {
                    error: 601,
                    msg: '长连接出现错误，重试失败，请尝试重新连接！',
                };
                WebSocketService.ws = null;
                WebSocketService.isReconnecting = false;
                eventEmitter_1.default.emit(WebSocketService.listenerHook, errorMsg);
                eventEmitter_1.default.emit(`${enum_1.EEventType.RECONNECT}`, errorMsg);
            }
        });
    }
    onOpen(ev) {
        return __awaiter(this, void 0, void 0, function* () {
            WebSocketService.isOpen && eventEmitter_1.default.emit(`${enum_1.EOpenEventType.OPEN}`, ev);
            yield WebSocketService._sendHandShakeMsg();
        });
    }
    onError(ev) {
        return __awaiter(this, void 0, void 0, function* () {
            WebSocketService.isOpen && eventEmitter_1.default.emit(`${enum_1.EOpenEventType.ERROR}`, ev);
            this.wsState = 'ERROR';
            if (!WebSocketService.isReconnecting) {
                console.log('WS:长连接出错，尝试重连');
                yield this.reconnect();
                return;
            }
            if (WebSocketService.isReconnecting) {
                eventEmitter_1.default.emit(`${enum_1.EEventType.RECONNECT_STATUS}`, {
                    error: 602,
                    msg: 'reconnect error',
                });
            }
        });
    }
    onClose(ev) {
        return __awaiter(this, void 0, void 0, function* () {
            WebSocketService.isOpen && eventEmitter_1.default.emit(`${enum_1.EOpenEventType.CLOSE}`, ev);
            this.wsState = 'CLOSED';
            if (WebSocketService.initClose) {
                console.log('WS:用户主动关闭');
                WebSocketService.ws = null;
                WebSocketService.isOpen = false;
                WebSocketService.hbInterval && clearInterval(WebSocketService.hbInterval);
                WebSocketService.initClose = false;
                return;
            }
            if (!WebSocketService.isReconnecting) {
                console.log('WS:长连接被动关闭，尝试重连');
                yield this.reconnect();
                return;
            }
            if (WebSocketService.isReconnecting) {
                eventEmitter_1.default.emit(`${enum_1.EEventType.RECONNECT_STATUS}`, {
                    error: 603,
                    msg: 'reconnect close',
                });
            }
        });
    }
    onMessage(ev) {
        return __awaiter(this, void 0, void 0, function* () {
            WebSocketService.isOpen && eventEmitter_1.default.emit(`${enum_1.EOpenEventType.MESSAGE}`, ev);
            const { data } = ev;
            if (data === 'pong') {
                console.log('WS:接收到心跳信息', data);
                return;
            }
            const decodedData = JSON.parse(data);
            if (decodedData.error === 0 && decodedData.config && decodedData.config.hb) {
                console.log('WS:长连接握手成功');
                this.wsState = 'CONNECTED';
                WebSocketService.isOpen = true;
                WebSocketService.sendMessage('ping');
                WebSocketService.hbInterval = setInterval(() => {
                    WebSocketService.sendMessage('ping');
                }, (decodedData.config.hbInterval - 7) * 1000);
                WebSocketService.isReconnecting = false;
                eventEmitter_1.default.emit(WebSocketService.listenerHook, {
                    error: 0,
                    msg: 'success',
                });
                return;
            }
            if (decodedData.error !== 0 && decodedData.actionName === 'userOnline') {
                console.log('WS:长连接握手出错');
                return;
            }
            if ((decodedData.hasOwnProperty('error') && decodedData.deviceid) || decodedData.params) {
                const { sequence, deviceid } = decodedData;
                eventEmitter_1.default.emit(`${enum_1.EEventType.DEVICE_MSG}${sequence}${deviceid}`, decodedData);
            }
        });
    }
    static sendMessage(params) {
        if (WebSocketService.ws && WebSocketService.ws.readyState === 1) {
            if (typeof params === 'string') {
                WebSocketService.ws.send(params);
                return;
            }
            if (params.hasOwnProperty('sequence')) {
            }
            WebSocketService.ws.send(JSON.stringify(params, null, 4));
        }
    }
    static _sendHandShakeMsg() {
        return __awaiter(this, void 0, void 0, function* () {
            let params;
            if (WebSocketService.connectConfig.userAgent === 'device') {
                const { userAgent, apikey, chipid, deviceid } = WebSocketService.connectConfig;
                params = {
                    action: 'register',
                    userAgent,
                    apikey,
                    deviceid,
                };
                chipid && (params.chipid = chipid);
            }
            else {
                const { appid, userAgent, at, apikey } = WebSocketService.connectConfig;
                params = {
                    action: 'userOnline',
                    version: 8,
                    ts: tools_1.createAppTs(),
                    at,
                    userAgent,
                    apikey,
                    appid,
                    nonce: tools_1.createNonce(),
                    sequence: `${Date.now()}`,
                };
            }
            WebSocketService.sendMessage(params);
        });
    }
    sendThing(deviceConfig, action) {
        return __awaiter(this, void 0, void 0, function* () {
            const { deviceid, params, ownerApikey } = deviceConfig;
            const sequence = `${Date.now()}`;
            const notDevice = WebSocketService.connectConfig.userAgent !== 'device';
            let deviceParams = {
                action,
                deviceid,
                apikey: ownerApikey,
                userAgent: WebSocketService.connectConfig.userAgent,
                sequence,
                params,
            };
            action === 'query' && notDevice && (deviceParams.selfApikey = WebSocketService.connectConfig.apikey);
            WebSocketService.sendMessage(deviceParams);
            return deviceParams;
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (WebSocketService.ws) {
                return {
                    error: 0,
                    msg: 'Web socket is already exist.',
                    data: WebSocketService.ws,
                };
            }
            return yield this._initWs();
        });
    }
    close() {
        if (WebSocketService.ws) {
            WebSocketService.initClose = true;
            WebSocketService.ws.close();
            WebSocketService.ws = null;
            WebSocketService.hbInterval && clearInterval(WebSocketService.hbInterval);
            eventEmitter_1.default.removeAllListeners();
        }
    }
    send(params) {
        if (WebSocketService.ws) {
            WebSocketService.sendMessage(params);
        }
    }
}
exports.default = WebSocketService;
WebSocketService.initClose = false;
WebSocketService.isReconnecting = false;
